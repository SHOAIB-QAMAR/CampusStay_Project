// (I) <Phase-1-Part-a>

// (1) <Basic Set Up> 

    (*) npm init -y
    (*) npm i express
    (*) npm i ejs
    (*) npm i mongoose

// (2)  Listing Model 

    (*) <virtuals> : https://mongoosejs.com/docs/guide.html#virtuals

        -> Virtuals in Mongoose are properties that do not get stored in the database but are dynamically computed based on existing fields.
           Virtuals are document properties that you can get and set but that do not get persisted <saved to the database permanently> to MongoDB
        -> Why Use Virtuals?
            @ Getters: Used to format or combine fields.
            @ Setters: Used to decompose a single value into multiple fields.

        (*) set: (v) => v === "" ? "default link" : v

// (3) Initialize Data

// (4) <Initialize Database> 

        (*) cd init
        (*) node index.js

        (*) <db.listings.find()>  Returns Only a Limited Number of Documents
            <db.listings.find().toArray()>  : fetch all documents

// (5) <Index Route>

    GET      /listings    : all listings 

// (6) <Read> : Show Route 

    GET     /listings/:id   : all particular data about listing

    (*) <Inserting Commas> : The .toLocaleString() function is used in JavaScript to format numbers and dates according to a specific locale.
    
        number.toLocaleString("en-IN")

// (7) <Create> [ New & Create Route ]

    GET     /listings/new
    POST    /listings
    
// (8) <Update> [Edit & Update Route] 

    GET     /listings/:id/edit
    PUT     /listings/:id

    (*) <npm i method-override> 

// (9) <Delete>  [Delete Route]


// (II) <Phase-1-Part-b>

// (1) <BoilerPlate> 

    (*) <npm install ejs-mate> 
        
// (2) <NavBar>

    (*) When integrating Bootstrap into your project, you might encounter situations where your external CSS styles don't seem
        to take effect as expected. This typically arises due to the cascading nature of CSS, where the order of stylesheets and
        the specificity of selectors determine which styles are applied.

    (*) https://getbootstrap.com/docs/5.3/components/navbar/

    (*) <font-awesome> , include <Font_Awesome CDN>

    (*) The <__ !important  > rule in CSS overrides all previous styling rules, including inline styles and styles from external
            stylesheets. It gives the highest priority to a specific CSS rule.

// (3) <Styling Index> 

    (*) Bootstrap card for styling index

// (4) <Styling New Listings>

    (*) Bootstrap Overview

// (5) <Styling Edit Listings>

// (6) <Styling Show Listings>

    (*) Bootstrap card for styling index

// (III) <Phase-1-Part-c>

// (1) <Client Side Validation (Form)>

    <https://getbootstrap.com/docs/5.3/forms/validation/>

    When we enter data in the form, the browser or web server
    will check to see that the data is in the correct format and
    within constraints set by application.

    (*) Make input fields <required>, here the problem is that on
        different browser different required field messages shown
        so, we need to make standarized (i.e <new.ejs>).

// (2) <Success and Failure Text>

    Form validation & Success, Failure text (i.e. <edit.ejs>).

    (*) We validate client side data, but when we send data
        from hopscotch/postman than invalid data may be saved 
        i.e server side validation required (i.e. <new.ejs>).

    -> Since, we make client side validation from <Form> but if user send 
        data directly from <Hopscotch, Postman> than data validation not happen
        i.e. Server Side Validation.

// (3) <Custom Error Handling>

    If any error happen due <Hopscotch, Postman> we can handle
    in try-catch block using middleware (i.e. <index.js>).

// (4) <Custom wrapAsync>

    <utility/wrapAsync.js>

// (5) <Custom ExpressError>

// (6) <Error.ejs>     [https://getbootstrap.com/docs/5.3/components/alerts/]

    <Alerts> : Provide contextual feedback messages for typical user actions with the handful of available and flexible alert messages.

// (7) <Validation for Schema>

    Since, in previous case we only deal with <req.body> for missing 
    title. But sometime title provided, some parameter are missing
    in this case <document> created without all paramters required.
    This handle by checking all document's parameter separately.

    (*) Since, we handle schema validation using <if statement>
        which is bulky.

        Alitor: <https://joi.dev/api/?v=17.13.3>

        The most powerful schema description language and data validator for JavaScript.

        (*) <npm i joi>

// (8) <Validation for Schema with Middleware>

// (IV) <Phase-2-Part-a:3>

    (1), (2) </Users/shoaibqamar/Desktop/S6Backend/DB-Relationship/Models>

// (3) <Creating Review Model> : models/reviews.js

// (4) <Create Review [1]> : Form Creation

// (5) <Create Review [2]> : Data Submit by <POST> Request

// (6) <Validation for Reviews> : Client side as well as JOI

// (7) <Render Reviews> 

// (8) <Deleting Reviews>  

    $pull operator removes from an existing array all instances
    of a value or values that matches a specified condition.

// (V) <Phase-2-Part-b>

// (1) <Express Router> : Classroom

    In Express.js, a Router is a way to create modular, mountable route handlers. It helps organize routes for different
    parts of your app, making your code more readable and maintainable.
    A router object is an instance of middleware and routes. You can think of it as a ‚Äúmini-application,‚Äù capable only of
    performing middleware and routing functions. Every Express application has a built-in app router.

    Here, we shifted all index.js listing, review code to routes listing.js, review.js.

// (2) <mergeParams> Preserve the req.params values from the parent router. If the parent and the child have conflicting param
        names, the child‚Äôs value take precedence. 
        Default = false

// (3) <Restructuring> Primary file does not bloated <Classroom>

// (4) <Cookies> HTTP cookies are small blocks of data created by
        a web server while a user is browsing a website and placed
        on the user's computer or other device by user's web browser.

// (5) <Send Cookies> https://expressjs.com/en/5x/api.html#req.cookies

    req.cookies is a property in Express.js (a Node.js web application framework) that holds cookies sent by the client in
    the request. It is available when you use the cookie-parser middleware.

    <npm install cookie-parser> Parse Cookie header and populate req.cookies with an object keyed by the cookie names.

// (6) <Signed Cookies> https://expressjs.com/en/5x/api.html#res.cookie

// (VI) <Phase-2-Part-c> : Classroom

// (1) <State>

    <Stateful Protocol> Require server to save the status and session information
        e.g ftp
    <Statefuless Protocol> Does not require the server to retain the server information
        e.g http

// (2) <Express Session> : An attempt to make our session stateful

        (*) On the server-side, data is stored in a temporary storage (like memory, a file store, or a database).
        (*) The server creates a session ID to identify this stored data.
        (*) This session ID is then sent to the client's browser as a cookie.
        (*) On subsequent requests, the browser sends back the session ID cookie, allowing the server to retrieve the associated
            session data ‚Äî making the session stateful.

        <npm install express-session>

        <secret : Required option>
        
        This is the secret used to sign the session ID cookie. The secret can be any type of value that is supported by Node.js.
        This can be either a single secret, or an array of multiple secrets. If
        an array of secrets is provided, only the first element will be used to sign the session ID cookie, while all the
        elements will be considered when verifying the signature in requests. The secret itself should be not easily parsed by a
        human and would best be a random set of characters

// (3) <Session Option>

    In particular browser, cookies id remain same for all tabs.
    But different for other particular browser (safari, chrome)

<resave: false>
Prevents unnecessary session saves.
If the session hasn‚Äôt changed during a request, it won‚Äôt be saved again.
Helps reduce load on the session store (especially important for databases).

<saveUninitialized: true>
Saves a new but empty session to the store.
Can be useful for implementing things like login tracking or consent notices.

<Warning> The default server-side session storage, <MemoryStore>, is purposely not designed for a production environment. It
will leak memory under most conditions, does not scale past a single process, and is meant for debugging and developing.
Compatible session stores : https://www.npmjs.com/package/express-session#compatible-session-stores

// (4) <Storing & Using Info>

// (5) <Connect-Flash> The flash is a special area of the session  used for storing messages.
        messages are written to the flash and cleared after being displayed to user.
        The flash is typically used in combination with redirects, ensuring that the message is available to the next page that
        is to be rendered.
        <npm install connect-flash>

// (6) <res.locals>  https://expressjs.com/en/5x/api.html#res.locals
        res.locals is an object in Express that allows you to pass data from middleware to your views (or route handlers) for
        the current request. Think of it as a temporary container for request-specific variables that will be available when
        rendering a page.

// (7) <Implement Session in Project> : Project

    <npm install express-session>

// (8) <Cookie in Session Project> : https://www.npmjs.com/package/express-session

    üç™ cookie.expires in Express :-
    The cookie.expires option is used to set the exact date and time when a cookie should expire and be removed from the browser.
    This tells the browser to keep the cookie until the specified date.
    After the expiration time, the cookie is automatically deleted by the browser.

    Option      Type            Description
    expires     Date object     Sets the exact expiration time
    maxAge      Number (ms)     Sets how long (from now) the cookie lasts

    If you don't set expires or maxAge, the cookie is called a
    <Session cookie>
    It lasts until the browser is closed.
    Then it gets automatically deleted.

    ‚úÖ Benefits of httpOnly: true
    Prevents Cross-Site Scripting (XSS) attacks:
    (*) If an attacker injects malicious JS into your page, they won‚Äôt be able to steal sensitive cookies like session tokens.
    (*) It's especially important for authentication/session cookies, since they hold sensitive data.

// (9) <Implement Flash> : Created flash in listing : npm install connect-flash
    
    [create:listing] -> index.js [app.use(Middleware)] -> listing -> view -> index.ejs

// (10) <Flash Success Includes>

    /Users/shoaibqamar/Desktop/S6Backend/Project/Phase/views/includes/flash.ejs

// (11) <Flash failure Includes>

// (VII) <Phase-2-Part-d> 

// (1) <Authentication>
        Process of verifying who someone is 
        e.g. login, sign in
    
        <Authorization>
        Process of verifying what specific applications,files 
        and data a user has access to

// (2) <How are password stored>

        We never store password as it is. We store their hashed form 

// (3) <Hashing Function> 

        For every input, there is a fixed output
        They are 1 way function, we can't get input from output
        For each different input,there is different output of same length
        Small change in input should bring large changes in output

// (4) <Salting> 

        Password salting is a technique to protect passwords stored 
        in database by adding a string of 32 or more characters and 
        then hashing them.
        Protection from <Reverse Lookup Table>

// (5) <Passport> 

    Passport is authentication middleware for Node.js. Extremely flexible and modular, Passport can be unobtrusively dropped
    in to any Express-based web application. A comprehensive set of strategies support authentication using a username and
    password, Facebook, Twitter, and more.

    <npm install passport>                : Passport is Express-compatible authentication middleware for Node.js.
    <npm install passport-local>          : This module lets you authenticate using a username and password in your Node.js applications.
    <npm install passport-local-mongoose> : Passport-Local Mongoose does not require passport or mongoose dependencies directly but expects you to have these dependencies installed.

// (6) <User Model> : Phase/models/user.js
    
// (7) <Configuring Strategy>

// (8) <Demo User> : 

    Passport-Local Mongoose use the <pbkdf2> algorithm of the node crypto library. PBKDF2 applies a pseudorandom function, such as hash-based message authentication code (HMAC), to the input password or passphrase along with a salt value and repeats the process many times to produce a derived key, which can then be used
    as a cryptographic key in subsequent operations. The added computational work makes password cracking much more difficult, and is known as key stretching.

    (i)  register(user, password, cb) : Convenience method to register a new user instance with a given password. Checks if username is unique.

// (9) <SignUp User>    GET /signup  +  POST   /signup

// (10) <LogIn User>    GET /login   +  POST /login   

    Authenticate - https://www.npmjs.com/package/passport#authenticate-requests

// (VIII) <Phase-2-Part-e>

// (1) <Connecting Login Route> How to check if user logged in?

    Make sure user should logged in while creating new listing.

// (2) <Logout Route> https://www.passportjs.org/concepts/authentication/logout/

    <req.logout> : Passport function

// (3) <Styling Nav Bar>

// (4) <Login after Signup> https://www.passportjs.org/concepts/authentication/login/

    Passport login method automatically establish a login session
    We can invoke login to automatically login a user.

    <req.logout> : Passport function

// (5) <Post login page> : Redirect to original page after login.

// (6) <Owner Listing> : 

    Only authorizes owner edit/delete listing & individual delete/add review cretaed by them.

    (1) <Owner> : Add in listing schema

// (7) <Authorization> 

Once logged in, we <edit/delete> another listing it should avoided.

listing.owner._id == CurrUser._id  than edit/delete perform

// (8) <Authorization for listing> 
    
    Protection from APIs to perform edit/delete operation from Hopscotch.

// (9) <Authorization for reviews>

    Each review associated with <author> make sure only author has access to delete his review.
    Make sure only logged in individual add reviews.

// (IX) <Phase-3-Part-a>

// (1) <MVC> 

    MVC stands for Model-View-Controller ‚Äî it's a design pattern used to organize your code, especially in web applications.
    
    <Model (M)>
    Handles data and business logic   :    Represents the database schema and communicates with the database    :   In Mongoose: your schemas/models (like User, Listing, etc.)
    <View (V)>
    Handles the UI (User Interface)     :   In your case: EJS templates (.ejs files) like login.ejs, index.ejs, etc     :   Displays data from the controller.
    <Controller (C) ‚Äî The Coordinator>
    The controller is the middleman between the Model and the View    :   Responsibilities of a Controller  :   Receive requests (e.g., from a route like POST /login)  :   Get or modify data using the Model  :   Pass data to the View (or send a redirect/response)     :   Decide what to do based on user input

// (2) <MVC for listings>

// (3) <MVC for reviews & users>

// (4) <Router.route>  :  https://expressjs.com/en/5x/api.html#router.route

    Returns an instance of a single route which you can then use to handle HTTP verbs with optional middleware. Use
    router.route() to avoid duplicate route naming and thus typing errors.

// (5) <Re-stylie Rating>  : https://github.com/LunarLogic/starability?tab=readme-ov-file -> https://github.com/LunarLogic/starability/blob/master/starability-css/starability-slot.css

// (6) <Image Upload> : Problem  1) Send files   2) Size limit

    i)   Form capable of sending files
    ii)  Instead saving files in mongoDb<size limit>, we prefer
         third party services <AWS, Azure, Cloud> for production
         after saving it return <URL/link>
    iii) Save returned link in mungoDb

// (7) <Manipulating Form> : Form send urlencoded data  

    For sharing file type data  : <enctype="multipart/form-data">

    <npm install --save multer> : Multer is a node.js middleware for handling multipart/form-data, which is primarily used for uploading files.

// (8) <Cloud Setup> 

    <Product environment credentials> are sensitive configuration values (like API keys, database URIs, secret tokens, etc.) used in production environments‚Äîi.e., when your app is live and used by real users.
    <env file> is used to store environment variables‚Äîlike configuration settings, secrets, or credentials‚Äîin key=value format. It's commonly used to keep sensitive information outside of your source code (especially in production).

    For accessing environment variables, use <npm install dotenv>
    Dotenv is a zero-dependency module that loads environment variables from a .env file into process.env

// (9) <Store Files> : Multer Store Cloudinary <npm install multer-storage-cloudinary>

    form(file) -> backend(parse) -> cloud(store) -> URL/link(file)

// (10) <Save link in mongodb> : Modify image -> image[url,filename] in schema

// (X) <Phase-3-Part-b>

// (1) <Edit listing image> 

// (2) <Image Preview for Edit Page> : Cloudinary image transformation

// (3) <Getting started with Maps> : https://console.mapbox.com/account/access-tokens/

// (4) <Our First Map> : https://docs.mapbox.com/mapbox-gl-js/guides/

    <Mapbox GL JS> is a client-side JavaScript library for building web maps and web applications with Mapbox's modern mapping technology.
    Since, js file can't directly access env variables, but accessible in <ejs>
    make available in <js> by : ejs create js variable as env variable

// (5) <Geocoding> : https://docs.mapbox.com/api/search/geocoding/

    The process of converting addresses(like street address) into 
    geographical coordinates(like latitude and longitude), which 
    you can use to place markers on a map, or position the map.

    <https://github.com/mapbox/mapbox-sdk-js/blob/main/docs/services.md#forwardgeocode-1> 

    <npm install @mapbox/mapbox-sdk>

// (6) <Storing Coordinate> : https://mongoosejs.com/docs/geojson.html

    GeoJSON is a format for storing geographic points and polygons.

// (7) <Map Marker> : https://docs.mapbox.com/mapbox-gl-js/example/add-a-marker/

                    : https://docs.mapbox.com/mapbox-gl-js/api/markers/

// (8) <Popup> : https://docs.mapbox.com/mapbox-gl-js/api/markers/#popup

// (XI) <Phase-3-Part-c>

// (1) <Fixing Home Page>

// (2) <Add UI for Filters> 

// (3) <Add UI for Tax Switch> : Add category option in model
                                 Add tax switch and eventListener 

// (4) <Making Tax Switch Functional>

// (5) <Add UI for search> : https://getbootstrap.com/docs/5.3/components/navbar

// (XII) <Phase-3-Part-c>

// (1) <Use Mongo Atlas> : Cloud Database services

    shoaibqamar539  -   H48vteHG5HZ1nVKO 
    mongodb+srv://shoaibqamar539:H48vteHG5HZ1nVKO@cluster0.wsudyvg.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0

    Instead mongo-url --> cluster0

// (2) <Mongo Session Store>  : https://expressjs.com/en/resources/middleware/session.html#compatible-session-stores

    The default server-side session storage, MemoryStore, is purposely not designed for a production environment. It will
    leak memory under most conditions, does not scale past a single process, and is meant for debugging and developing

    <connect-mongo> A MongoDB-based session store.
    https://www.npmjs.com/package/connect-mongo

// (3) <Deployment>  * render   * netlify   * cyclic

    Modify package.json :
    "engines": {
        "node": "23.10.0"
    }

// (4) <Connect Render with Github>